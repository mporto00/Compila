options
{
  static = false; //Nao criara metodos estaticos
  DEBUG_LOOKAHEAD = true;
}

PARSER_BEGIN(Fun)
package parser;

import java.io.*;
import recovery.*; // importa as classes de recuperacao	de erros do AS

public class Fun
{
   int contParseError = 0; // contador de erros sintaticos
   boolean debug_recovery; // controla verbose de recuperacao de erros
   boolean Menosshort = false;
   Token lastError = null;
    
	public static void main(String args []) throws ParseException {
	    boolean debug_as = false;
	    boolean debug_recovery = false;
	    
	    boolean debug = false;
	    Fun parser = new Fun(System.in);
	    String filename = "aceitos.txt";
	    int i;
	    boolean ms = false;   
	
	    for (i=0 ; i < args.length - 1 ; i++) {
	
			if ( args[i].equals("-debug_AS")) 
				debug_as = true;
			else
			if (args[i].equals("-debug_recovery")) 
				debug_recovery = true;
			 else {
				System.out.println("Metodo de uso e: Java LangFun [-debug_AS]" + "[-debug_recovery] inputfile");
				System.exit(0);
			}
		}
	/*
	    	if ( args[i].toLowerCase().equals("-short"))
	    		ms = true;
	    	else {
	    		System.out.println("Método de uso é: Java LangFun [-short] inputfile");
	    		System.exit(0);
	    	}
	    }
	*/
		// lê entrada padrao
		// if (args[i].equals("-")) {
		  if (false) { 
			System.out.println("Lendo entrada padrao..");
			parser = new Fun(System.in); // cria AS
		}
		// lê do arquivo
		else {
		    //filename = args[args.length-1];
			System.out.println("Lendo do arquivo " +  filename);
	    	try {
	    		parser = new Fun (new java.io.FileInputStream(filename) );
	    	} catch (java.io.FileNotFoundException e) {
	    		System.out.println("Arquivo " + filename + " nao encontrado.");
	    		return;
	    	}
		}
		/*
	    //if (args[i].equals("-"))
	    if (false)
	    {
	    	System.out.println("Lendo entrada padrão..");
	    	parser = new Fun(System.in);
	   
	    } else
	    {
	    	//filename = args[args.length-1];
	    	//filename = args[args.length-1];
	    	System.out.println("Lendo do arquivo " +  filename);
	    	try {
	    		parser = new Fun (new java.io.FileInputStream(filename) );
	    	} catch (java.io.FileNotFoundException e) {
	    		System.out.println("Arquivo " + filename + " não encontrado.");
	    		return;
	    	}  	
	    }
	    */
	
	     parser.debug_recovery = debug_recovery;
	     if (!debug_as) parser.disable_tracing(); // desabilita verbose do AS
	     try {
	       	parser.program();   // chama o método que faz a análise
	     }
	     catch (ParseEOFException e)
	     {
	           System.err.println(e.getMessage());
	       //parser.contParseError = 1;  //  não existe recuperação de erros
	       }
	       finally {
	           System.out.println(parser.token_source.foundLexError() + " erros lexico encontrados");
	           System.out.println(parser.contParseError + " erros sintaticos encontrados");
	       }
	} // main
	
static public String im(int x) {
	int k;
    String s;
    s = tokenImage[x];
    k = s.lastIndexOf("\"");
    try {s = s.substring(1,k);}
    catch (StringIndexOutOfBoundsException e)
    {}
    return s;
}

boolean eof;	// variavel que indica se o EOF foi alcançado
// o metodo abaixo consome tokens ate alcançar um que pertença
// ao conjunto de sincronizaçao

void consumeUntil (RecoverySet g,
				   ParseException e,
				   String met) throws ParseEOFException,
				   					  ParseException {
	Token tok;

	// informacao sobre a recuperacao
	if ( debug_recovery ) {
		System.out.println();
		System.out.println("*** " + met + " ***");
		System.out.println("	Syncronizing Set: " + g);
	}
	if ( g == null ) throw e; // se conjunto e null propaga a excecao
	tok = getToken(1); // pega token corrente

	// se nao chegou no fim do arquivo
	while ( !eof ) {
		// achou um token no conjunto
		if ( g.contains(tok.kind )) {
			if (debug_recovery ) 
				System.out.println("	Found Syncronizing token: " + im(tok.kind));
				break;
		}
		if (debug_recovery ) 
			System.out.println("	Ignoring token: " + im(tok.kind));
		getNextToken(); // pega proximo token
		tok = getToken(1);

		// fim da entrada
		if (tok.kind == EOF && !g.contains(EOF))
			eof = true;
	}

	if ( tok != lastError) {
		System.out.println(e.getMessage());
		lastError = tok;
		contParseError++; // incrementa numero de erros
	}
	if ( eof ) throw new ParseEOFException ("EOF found prematurely.");
}
} // fun

PARSER_END(Fun)

TOKEN_MGR_DECLS : {
int	countLexError = 0;

public int foundLexError() {
	return countLexError;
  }
}
  
SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
| "\f"
}

//comentário de bloco
SKIP : 
{ 
 "/*" : multilinecomment
}

<multilinecomment> SKIP :
{ 
 "*/" : DEFAULT
| <~[]>
}

//comentário de linha
SKIP : 
{ 
 "//" : singlelinecomment
}

<singlelinecomment> SKIP :
{ 
 <["\n","\r"]> : DEFAULT
| <~[]>
}

TOKEN : /* OPERATORS */
{
  < ASSIGN : "=" >
| < GT : ">" >
| < LT : "<" >
| < EQ : "==" >
| < LE : "<=" >
| < GE : ">=" >
| < NEQ : "!=" >
| < PLUS : "+" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < DIVIDE : "/" >
| < REM : "%" >

/*added*/

| < AND: "and">
| < OR: "or">
| < XOR: "xor">
| < NOT: "not">
}

// SIMBOLOS ESPECIAIS
TOKEN :
{
  < SEMICOLON : ";" >
| < COMMA : "," >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < LBRACE : "{" >
| < RBRACE : "}" >
| < DOT : "." >
}
//RESERVED WORDS

TOKEN :
{
  <BREAK: "break">
| <CLASS: "class">
| <CONSTRUCTOR: "constructor">
| <ELSE: "else">
| <EXTENDS: "extends">
| <FOR: "for">
| <IF: "if">
| <NEW: "new">
| <PRINT: "print">
| <READ: "read">
| <RETURN: "return">
| <SUPER: "super">
| <INT: "int">
| <STRING: "string">
| <FLOAT: "float">
| <BOOLEAN: "boolean">
| <CHAR: "char">
}

//IDENTIFIER TOKEN

TOKEN : /* CONSTANTES NUMERICAS */
{
		< float_constant: <int_constant> "." ( <int_constant> )+ >
  | 	< int_constant: ( <DIGIT> )+
  |     (["0"-"7"] (["0"-"7"])* ["o", "O"] ) 
  |     ((<DIGIT> | ["A"-"F","a"-"f"])* ["h", "H"] )
  |     (["0"-"1"] (["0"-"1"])* ["b", "B"]) >
  | 	< #DIGIT: ["0" - "9"] >
}

TOKEN : {
  
  <#LETTER: (["a"-"z","A"-"Z"])> 
| <CONSTANT : (< DIGIT >)+ >
| <boolean_constant: <TRUE> | <FALSE>  >
| <char_constant :"'"~[]"'" | "'\\n'" >
| <IDENTIFIER: <LETTER>(<LETTER>|<DIGIT>)*(["$"])?>
| <string_constant: "\""( ~["\"","\n","\r"])* "\"" >
| <#TRUE: "true" | "TRUE" >
| <#FALSE: "false" | "FALSE" >
| <null_constant: "null" >
}

//TOKEN P/ LANÇAR ERRO LÉXICO
SPECIAL_TOKEN : {
<INVALID_LEXICAL:
(~["a"-"z", "A"-"Z",
   "0"-"9",
   "\"",
	"(",
	")",
	"[",
	"]",
	"{",
	"}",
	"<",
	">",
	"=",
	";",
	",",
	"!",
	"+",
	"-",
	"*",
	"/",
	"%",
	" ",
	"\t",
	"\n",
	"\r",
	"\f"])+> {
	  	System.err.println("Line " + input_stream.getEndLine() + " - invalid string found: " + image);
	  	countLexError++;
	 }	
| < INVALID_CONST:
	"\"" (~ ["\n","\r","\""])* ["\n","\r"] > {
	    System.err.println("Line " + input_stream.getEndLine() + " - String constant has a \\n: " + image);
	  	countLexError++;
	  }
| < INVALID_CHAR:
	"'" (~ ["\n","\r","'"])* ["\n","\r"] > {
	    System.err.println("Line " + input_stream.getEndLine() + " - Char constant has a \\n: " + image);
	  	countLexError++;
	  }

}


void program() throws ParseEOFException :
{
	RecoverySet g = First.program;
}
{
  <EOF>
|
	classlist(g)
  	try { 
  		<EOF>
    }
	catch (ParseException e) {
		consumeUntil(g, e, "program");
	}
	[ program() ]
}

void classlist(RecoverySet g) throws ParseEOFException :
{
RecoverySet f = First.classlist.union(g);
}
{
   classdecl(f)[LOOKAHEAD(2) classlist(g)]
}

void classdecl(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(CLASS).union(g);
}
{
try { 
  <CLASS> <IDENTIFIER> [ <EXTENDS> <IDENTIFIER> ] classbody(g)
}
catch (ParseException e){
	consumeUntil(g, e, "classdecl");
}
}

void classbody(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f2 = new RecoverySet(SEMICOLON).union(g).remove(IDENTIFIER),
  			  f3 = First.methoddecl.union(g).remove(IDENTIFIER),
  			  f4 = First.constructdecl.union(f3).remove(IDENTIFIER),
  			  f5 = First.vardecl.union(f4).remove(IDENTIFIER);
}
{
  try { 
    <LBRACE>
      [classlist(f5)]
      (LOOKAHEAD(3) vardecl(f2) <SEMICOLON>)*
      (LOOKAHEAD(3) constructdecl(f4) | LOOKAHEAD(3) methoddecl(f3) | LOOKAHEAD(3) vardecl(f2) <SEMICOLON>)*
   <RBRACE>
 } catch (ParseException e) {
		consumeUntil(g, e, "classbody");
   }
}

void vardecl(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(IDENTIFIER).union(g);
}
{
 try { 
  types(f) <IDENTIFIER> ( <LBRACKET> <RBRACKET>)* (LOOKAHEAD(1) assignment(g))?
  (<COMMA> <IDENTIFIER> ( <LBRACKET> <RBRACKET>)* )* (LOOKAHEAD(1) assignment(g))?
}
catch (ParseException e) {
	consumeUntil(g, e, "vardecl");
  }
}

void constructdecl(RecoverySet g) throws ParseEOFException:
{
}
{
 try {
    <CONSTRUCTOR> methodbody(g)
}
catch (ParseException e)
{
   consumeUntil(g, e, "constructdecl");
}
}

//SIMPLIFICAÇÃO DE CODIGO, SE VC ESTIVER LENDO ISSO PROFESSOR, NAO DESCONTE 1 PONTO NOSSO. ATT, A DIREÇAO
void types(RecoverySet g) throws ParseEOFException :
{
}
{
 try{
  ( <INT> | <FLOAT> | <CHAR> | <STRING> | <IDENTIFIER> | <BOOLEAN>)
  }catch (ParseException e)
{
   consumeUntil(g, e, "types");
}
}

void methoddecl(RecoverySet g) throws ParseEOFException:
{
  RecoverySet f = new RecoverySet(IDENTIFIER).union(g);
}
{
  try {
   types(f) (<LBRACKET> <RBRACKET>)* 
   <IDENTIFIER> methodbody(g)
 }
  catch (ParseException e)
  {
   consumeUntil(g, e, "methoddecl");
  }
}

void methodbody(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
  try { 
    <LPAREN> paramlist(f) <RPAREN> statement(g)
  }
  catch (ParseException e) {
		consumeUntil(g, e, "methodbody");
   }
}

void paramlist(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(IDENTIFIER).union(g);
}
{
  try { 	
   [
    types(f1) <IDENTIFIER> (<LBRACKET> <RBRACKET>)*(LOOKAHEAD(1) assignment(g))?
    (<COMMA> types(f1) <IDENTIFIER> (<LBRACKET> <RBRACKET>)* (LOOKAHEAD(1) assignment(g))?)* 
	
   ]
 }
 catch (ParseException e) {
		consumeUntil(g, e, "paramlist");
   }
}

void statement(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g).remove(IDENTIFIER);
  RecoverySet f2 = new RecoverySet(RBRACE).union(g).remove(IDENTIFIER);
}
{
  try { 
    LOOKAHEAD(<IDENTIFIER> <IDENTIFIER>)
    vardecl(f1) <SEMICOLON>
|
	LOOKAHEAD(1)
    atribstat(f1) <SEMICOLON> 
|
    printstat(f1) <SEMICOLON>
|
    readstat(f1) <SEMICOLON>
|
    returnstat(f1) <SEMICOLON>
|
    superstat(f1) <SEMICOLON>
|
    ifstat(g) 
|
    forstat(g) 
|
    <LBRACE> statlist(f2) <RBRACE> 
|
    <BREAK> <SEMICOLON>
|
    <SEMICOLON>
  }
  catch (ParseException e) {
		consumeUntil(g, e, "statement");
  }
}

void atribstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(ASSIGN);
}
{
  try { 
    lvalue(f1) assignment(g)
  }	
  catch (ParseException e) {
		consumeUntil(g, e, "atribstat");
  }
}

void printstat(RecoverySet g) throws ParseEOFException :	
{
}
{
  try { 
    <PRINT> expression(g)
  }
  catch (ParseException e) {
	consumeUntil(g, e, "printstat");
  }
}

void readstat(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
    <READ> lvalue(g)
  }
  catch (ParseException e) {
	consumeUntil(g, e, "readstat");
  }
}


void returnstat(RecoverySet g) throws ParseEOFException :
{
}
{  
  try { 
    <RETURN> [expression(g)]
  }
  catch (ParseException e) {
	consumeUntil(g, e, "returnstat");
  }
}


void superstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(RPAREN).union(g);
}
{
  try { 
    <SUPER> <LPAREN> arglist(f) <RPAREN>
  }
  catch (ParseException e) {
	consumeUntil(g, e, "superstat");
  }
}

void ifstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(RPAREN).union(g),
  			  f2 = new RecoverySet(ELSE).union(g);
}
{
  try { 
    <IF> <LPAREN> expression(f1) <RPAREN> statement(f2)
    [LOOKAHEAD(1) <ELSE> statement(g)]
  }
  catch (ParseException e) {
	consumeUntil(g, e, "ifstat");
  }
}



void forstat(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(SEMICOLON).union(g),
  			  f2 = new RecoverySet(RPAREN).union(g);
}
{
  try { 
    <FOR> <LPAREN> [atribstat(f1)] <SEMICOLON>
                   [expression(f1)] <SEMICOLON>
                   [atribstat(f2)] <RPAREN>
                    statement(g)
  }
  catch (ParseException e) {
	consumeUntil(g, e, "forstat");
  }
}

void assignment(RecoverySet g) throws ParseEOFException :
{
}
{
    <ASSIGN> (alocexpression(g) | expression(g))
}

void  statlist(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = First.statlist.remove(IDENTIFIER).union(g);
}
{
   statement(f) [statlist(g)]
}

void lvalue(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
   <IDENTIFIER> (
           <LBRACKET> expression(null) <RBRACKET> |
           <DOT> <IDENTIFIER> [<LPAREN> arglist(null) <RPAREN>]
         )*
  	}
  	catch (ParseException e) {
		consumeUntil(g, e, "lvalue");
  	}
}

void alocexpression(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f1 = new RecoverySet(RPAREN).union(g),
  			  f2 = new RecoverySet(RBRACKET).union(g);
}
{
    <NEW> ( 
             LOOKAHEAD(2) <IDENTIFIER> <LPAREN> arglist(f1) <RPAREN> | 
             types(g)
             (<LBRACKET> expression(f2) <RBRACKET>)+
          )
} 

void expression(RecoverySet g) throws ParseEOFException :
{
}
{
  try { 
    numexpr() [( <LT> | <GT> | <LE> | <GE> | <EQ> | <NEQ> | <AND> | <OR> | <XOR>) numexpr()]
  }
  catch (ParseException e) {
		consumeUntil(g, e, "expression");
  }
}

void numexpr() throws ParseEOFException :
{
}
{
    term() ((<PLUS> | <MINUS>) term())*
}

void term() throws ParseEOFException :
{
}
{
    unaryexpr() ((<MULTIPLY> | <DIVIDE>| <REM>) unaryexpr())*
}

void unaryexpr() throws ParseEOFException :
{
}
{
   [(<PLUS> | <MINUS>)] factor()
}


void factor() throws ParseEOFException :
{
}
{

   (<NOT>)? 
    ( 
       <char_constant> |
       <int_constant> | 
       <float_constant> | 
       <string_constant> | 
       <boolean_constant> |
       <null_constant> |
       lvalue(null) |
       <LPAREN> expression(null) <RPAREN>)
}

void arglist(RecoverySet g) throws ParseEOFException :
{
  RecoverySet f = new RecoverySet(COMMA).union(g);
}
{
    [expression(f) (<COMMA> expression(f))*]
}